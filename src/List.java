public class List {
    private Node head;//голова, первый эл-т списка
    private Node tail;//хвост, конец списка

    public List() { // конструктор, который инициализирует пустой связанный список
        head = null;
        tail = null;
    }

    private boolean isEmpty() {//метод для проверки, является ли список пустым
        return head == null;
    }

    public void addFirst(int data) {//добавление в начало
        Node temp = new Node(data);//создание нового узла
        if (isEmpty())//проверка, пустой ли список
            tail = temp;//если список пустой, то вставленный узел становится хвостом списка
        else head.prev = temp;//если не пустой, то к голове устанавливается новый узел temp

        temp.next = head;//чтобы temp указывал на текущую голову списка
        head = temp;//обновление головы списка
    }

    public void addLast(int data) {//добавление в конец
        Node temp = new Node(data);
        if (isEmpty())
            head = temp;//если список пустой, то вставленный узел становится головой списка
        else tail.next = temp;//если не пустой, то к концу устанавливается новый узел temp

        temp.prev = tail;//чтобы temp указывал на текущий хвост списка
        tail = temp;//обновление хвоста списка
    }


    public void addByInd(int data, int index) {//добавление по индексу
        Node temp = head;//создание временной переменной temp, которая инициализируется на голову списка
        int c = 0;//отслеживание индекса
        while (temp != null && c != index) {//проход по всему списку до конца или пока "c" не будет равно заданному индексу
            temp = temp.next;//переход к следующему узлу
            c++;
        }

        Node cur = new Node(data);//новый узел
        temp.prev.next = cur;//это обновление ссылки на следующий узел предыдущего узла temp, т.е теперь предыдущий узел будет указывать на новый узел cur
        cur.prev = temp.prev;//чтобы cur указывал на предыдущий узел temp
        temp.prev = cur;//обновление ссылки на предыдущий узел текущего узла temp
        cur.next = temp;//обновление ссылки на следующий узел нового узла cur
    }

    public void removeFirst() {//удаление начального эл-та
        if (head.next == null) {//проверка, что в списке больше одного элемента
            tail = null;
        } else head.next.prev = null;//обновление ссылки на предыдущий узел для второго элемента списка, чтобы не было связи с предыдущим элементом, так как первый удален
        head = head.next;//обновление ссылки на голову списка
    }

    public void removeLast() {//удаление конечного эл-та
        if (head.next == null) {
            head = null;
        } else tail.prev.next = null;//обновление ссылки на следующий узел для предпоследнего элемента, чтобы не было связи с последним элементом, так как последний удален
        tail = tail.prev;//обновление ссылки на хвост списка
    }

    public void removeAt(int key) {//удаление по заданному ключу
        Node temp = head;
        while (temp.data != key) {//проверка каждого узла на соответствие заданному ключу
            temp = temp.next;//переход к следующему элементу
            if (temp == null)//если узел не содержит заданный ключ и достигнут конец списка, то возвращаемся из метода
                return;
        }
        if (temp == head)//если удаляемый узел temp является головой списка, то вызывается соответствующий метод
            removeFirst();
        else temp.prev.next = temp.next;//обновление ссылки на узел, пропуская удаляемый узел temp, т.е предыдущий узел temp должен ссылаться на следующий узел после temp

        if (temp == tail)//если удаляемый узел temp является хвостом списка, то вызывается соответствующий метод
            removeLast();
        else temp.next.prev = temp.prev;//обновление ссылки на узел, пропуская удаляемый узел temp, т.е следующий узел temp должен ссылаться на предыдущий узел перед temp
    }

    public void print() {//вывод
        Node temp = head;
        while (temp != null) {//пока temp не равен null, проходимся по списку
            System.out.println(temp.data);//вывод значения данных текущего узла
            temp = temp.next;//переходим к следующему узлу, двигаясь вперед по списку
        }
    }
}